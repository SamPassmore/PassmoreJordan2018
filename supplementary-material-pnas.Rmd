---
title: "Supplementary Material"
author: "Sam Passmore and Fiona Jordan"
date: "01/08/2018"
header-includes:
- \usepackage[labelformat=empty]{caption}
- \usepackage[maxfloats=256]{morefloats}
- \maxdeadcycles=1000
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[graphicx]{realboxes}
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
  pdf_document:
    toc: yes
#bibliography: bibliography.bibtex
---

```{r setup, include=FALSE}
options(scipen=999)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warnings = FALSE)

library(knitr)
library(kableExtra)
library(stringr)
library(dplyr)
library(coda)
library(purrr)
library(psych)
library(ggplot2)
library(gridExtra)
library(tidyr)
library(reshape2)
library(bayestraitr)

source('processing/helper.R')

kincodes = read.csv('data/kincodes', header = FALSE)

format_change = 'html'
```

# Data
## Kinship and social structure
All data was extracted from the D-PLACE Ethnographic atlas [github repository](https://github.com/D-PLACE/dplace-data). Counts of the number of societies used for the signal and ancestral state analyses for each languages family are in table S1. Question and variable codes are displayed below in table S2. Due to the nature of the analysis, all variables are binary coded. The numbers  in the value columns indicate the criteria for a society to have the terminology or social structure coded as present. For details on what each code indicates, refer to the Ethnographic Atlas codebook or the [D-PLACE github repository](https://github.com/D-PLACE/dplace-data/blob/master/datasets/EA/codes.csv).


```{r results='asis', message = FALSE}
files = list.files('data/anc-state', pattern = '*.btdata',
                   full.names = TRUE)

d = suppressWarnings(purrr::map(files, read.table))

t = lapply(d, nrow) %>%
  unlist() %>% 
  matrix(., ncol = 1)
dimnames(t) = list(c("Austronesian", "Bantu", "Uto-Aztecan"), "Count")

kable(t,
      caption = "Table S1: Count of societies in signal test and ancestral state analyses, by language family", 
      format = format_change) %>% 
  kable_styling()
```

<!-- \newpage -->
<!-- \blandscape -->
<!-- \Rotatebox{90}{ -->
```{r, results='asis', message = FALSE}
# summary info
summary = readxl::read_xlsx('../terminology-coevolution2/summary-results.xlsx', sheet = "all")

# data count info
files = list.files('data/co-evo/', pattern = "*.btdata", full.names = TRUE)

d = purrr::map(files, read.table)

t = lapply(d, nrow) %>%
  unlist() %>% 
  data.frame(count = .)
t$id = basename(files) %>% 
  tools::file_path_sans_ext(.)
t$id2 = str_remove(t$id, "(austronesian|bantu|uto)-")
t$lf = str_extract(t$id, "(austronesian|bantu|uto)")

t2 = dcast(t, id2~lf, value.var = "count")
t2 = apply(t2, 2, function(x) ifelse(is.na(x), "", x)) %>% 
  data.frame()

summary = suppressWarnings(left_join(summary, t2, by = "id2"))

s = summary %>% 
  select(terminology, t.question.code, t.value.code, `social structure`,
         ss.question.code, ss.value.code, austronesian.y, bantu.y, uto)

s = s[order(s$terminology),]
s = s[,]

kable(s, col.names = 
        c("terminology", "question", "value", "social structure", 
          "question", 'value', 'AN counts', 'BT counts', 'UA counts'), 
      caption = "Table S2: Data coding taken from D-PLACE and Co-evolutionary analyses data counts", format = format_change) %>% 
 kable_styling(full_width = TRUE)

```
<!-- \elandscape -->
<!-- \newpage -->
<!-- } -->

### Co-evolutionary hypotheses and references

```{r, results='asis', message = FALSE}
quotes = read.csv('figures/hypothesis-table.csv')

kable(quotes[,1:5], 
      caption = "Table S3: hypotheses from earliest found source with quotes, references and page numbers", format = format_change) %>% 
 kable_styling(full_width = TRUE)
```


## Phylogenies 

We tested hypotheses across three languages families, where data allowed. This was the Austronesian, Bantu, and Uto-Aztecan language phylogenies (@gray2009, @grollemund2015bantu, @Levinson_Greenhill_Gray_Dunn_2011). All language to phylogeny pairings were taken from decisions made in @kirby2016d.
In Austronesian, we sub-sampled 1000 phylogenies from a posterior sample of 4199 phylogenies. Austronesian phylogenies were estimated through linguistic data and supported by genetic evidence, and archaeological records. Detailed methods can be found in @gray2009. Trees were pruned from the original sample of 400 languages, to 80 languages based on data availability. In Bantu, we sampled 1000 from a posterior sample of 2000 phylogenies developed in @grollemund2015bantu. These trees were built using linguistic data and calibrated using the archaeological record. Trees were pruned from the original sample of 425 languages, to 69 languages based on data availability. In Uto-Aztecan, we sampled 1000 phylogenies from a posterior of 10,000 phylogenies modeled by @Levinson_Greenhill_Gray_Dunn_2011. This posterior was built using linguistic data. Trees were pruned from the original sample of 34 languages, to 19 based on data availability. All branch lengths are standardized to have a mean length of 0.1, as per BayesTraits recommendations. 

# Signal tests
We performed 4 signal tests to assess the hypotheses that shared ancestry was a constraint on kinship diversity. The phylogenetic ‘D’ test uses simulation to determine whether the clustering of binary variables on a phylogeny follow patterns of Brownian motion (D = 0 indicates perfectly Brownian clusters and D < 0 strong clustering) or random clustering (D = 1 indicates complete randomness). To test whether geography may also predict the distribution of terminologies, we used Mantel tests. Mantel tests use random permutation and Pearson’s correlation statistics to determine the correlation between two matrices. Here we compare log geographic distance, calculated with the Haversine formula, to a binary similarity matrix of each terminology present in each language family, each over the default setting of 999 permutations. To determine whether phylogenetic or geographic distances best determined the distribution of terminologies, we used partial Mantel tests. Partial Mantel tests control for a confounding third matrix, while comparing another two matrices. We perform a test between a terminology and geographic distance, controlling for phylogenetic distance, and another between terminology and phylogenetic distance, controlling for geographic distance. Phylogenetic distance is calculated using cophenetic distance, and the cophenetic function in R {stats} (R Core Team 2018). Table S3 shows the mean posterior result from 1000 phylogenies for all terminologies present within each language family. However, we only consider results viable if the terminology consists of more than 10% of the overall sample. All p-values are bonferonni corrected. 

The code for all signal tests can be found in file `analysis/signal-tests.R`. This file comes with helper functions `analysis/signal-functions` and `analysis/mantel-functions` for the D-statistic and Mantel tests respectively. 

```{r signal-table, results='asis'}
signal_files = list.files('results/signal-results/', 
                          pattern = "mean.csv", 
                          full.names = TRUE)
idx = !str_detect(signal_files, "ie") # leave IE for now
signal_files = signal_files[idx]

results_lang = map(signal_files, read.csv)
results = do.call(rbind, results_lang)

# make the names nice
results$X = str_remove(results$X, "name")

caption = "Table S4: Signal tests for each terminology within each langauge family. Columns 2 and 3 indicate the presence and absence of a terminology. Columns 4 to 6 are outputs from the D-statistic test. Columns 7 to 21 are output from Mantel tests. P-values and bonferonni corrected values shown"
c.names = c("Terminology", "Absent", "Present", "D", "Prob. Brownian", "Prob. Random", "Z-stat", "p-value","bonf-p", "Z-stat", "p-value", "bonf-p", "Z-stat", "p-value", "bonf-p", "Statistic", "p-value", "bonf-p", "Statistic", "p-value", "bonf-p")

results = results[,c(1:12,16:18,13:15,19:21)]

groups = sapply(results_lang, nrow) %>%
  cumsum()

# idx = results$Present / rowSums(results[,c("Absent", "Present")]) > 0.1
# results = results[idx,]

print(
    results %>% 
    kable(format = format_change, col.names = linebreak(c.names), 
          caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = 
                    c("striped", "bordered")) %>%
      kableExtra::group_rows("Austronesian", 1, groups[1]) %>%
      kableExtra::group_rows("Bantu", groups[1]+1, groups[2]) %>%
      kableExtra::group_rows("Uto-Aztecan", groups[2]+1, groups[3]) %>% 
      add_header_above(c(" " = 3, "D-statistic" = 3, 
                         "Geography" = 3, "Log-Geography" = 3,
                         "Phylogeny" = 3, "Log-Geo + Phy" = 3,
                         "Phy + Log Geo" = 3)) %>%
      add_header_above(c(" " = 6, "Mantel" = 9, 
                         "Partial Mantel" = 6)))

```

# Ancestral state
## MCMC review
Ancestral state inference allows us to estimate the probability of a particular terminology at the root of each language phylogeny, as well as estimating the patterns of change between each state. We perform Bayesian reversible-jump MCMC ancestral state inference kinship terminologies using BayesTraits V 3.0 Multistate (Pagel and Meade 2017). Multistate uses a posterior of phylogenies to estimate the probability of each terminology present in the taxa at the phylogeny root, and an estimation of the rate (Q) matrix. The reversible-jump approach searches the model space for an optimal solution by dynamically setting some rate parameters (i.e. transitions from one state to another) to zero. This results in searching the model space where we are confident transition rates are non-zero. The Q matrix shows the likelihood of changing from any state to any other. MCMC chains were run for 10^9^ iterations, sampling every 50,000 iterations with a burn-in of 10,000 iterations, to give a posterior sample of 20,000. Each analysis ran three times to test consistent MCMC convergence using the Gelman-Rubin diagnostic (Gelman and Rubin 1992). Due to uncertainty in the inference of the Bantu ancestral state, each terminology present in the phylogeny was 'fossilized' as the root to estimate likelihoods. Effectively, this forces the algorithm to build a model given a particular ancestral state and given the contemporary data. We can then compare the model fit across each constrained model. We calculate pairwise Bayes factors (BF) to assess the evidence for each response. BF < 3 indicates weak evidence, >3 positive evidence, and >10 very strong evidence. This is shown in section 3.1.1. 

```{r ancstate-mcmc, results='asis', warning=FALSE, eval = TRUE}
folders = paste0('results/anc-state/', c('austronesian', 'bantu', 'utoaztecan'))
gelmanrubin_table = matrix(NA, ncol = 2, nrow = 3, 
                           dimnames = list(basename(folders), 
                                           c("Point est.", "Upper C.I.")))
i = 5
for(f in folders){
  files = list.files(path = f, pattern = "*.Log.txt", full.names = TRUE)
  logs = map(files, bt_read.log)
  
  roots = map(logs, function(l){
    root_cols = str_detect(colnames(l), 
                           "(^Lh)|(^Root)|(^Global Rate)")
    root = l[,root_cols] %>% colMeans()
    round(root, 3)
  }) %>% 
    do.call(rbind, .)
  
  idx = str_detect(colnames(roots), "Root")
  old_names = colnames(roots)[idx] %>% 
    str_extract("[0-9]") %>% 
    as.numeric()
  new_names = kincodes[kincodes$V1 %in% old_names,2]
  colnames(roots)[idx] = as.character(new_names)
  
  roots = rbind(roots, colMeans(roots))
  rownames(roots) = c(1:3, "Mean")
  # gelman-rubin statistic
  all_mcmc = mcmc.list(map(logs, function(x) as.mcmc(x$Lh)))
  d1 = gelman.diag(all_mcmc)
  rownames(d1$psrf) = basename(f)
  
  gelmanrubin_table[basename(f),] = d1$psrf
  
  caption = paste0("Table S", i,": Three MCMC chains for the ", basename(f), " language family")
  
  ## print table
  print(
    roots %>% 
    kable(format = format_change, caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
  )
  i = i + 1
}

print(
  gelmanrubin_table %>% 
    kable(format = format_change, 
          caption = "Table S8: Gelman-Rubin tests of MCMC convergence for each langauge family",
          digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)

```

### Fossilized Bantu
#### MCMC Review

We fossilize the ancestral state for each possible terminology within Bantu in an attempt to determine the most plausible ancestral state. Below are the MCMC diagnostics for these models and the result with comparisons to an Iroquoian fossilized ancestral state. 

```{r fossilized-bantu-mcmc, results='asis'}
files = list.files('results/anc-state/fossilize-bantu/output', pattern = "Log.txt", 
                   full.names = TRUE)

stones_files = list.files('results/anc-state/fossilize-bantu/output', pattern = "Stones.txt", 
                   full.names = TRUE)

bantu_kincodes = stones_files %>% 
  basename() %>% 
  str_split("_") %>%
  sapply(extract2, 1) %>% 
  unique()

# gelmanrubin_table = matrix(NA, ncol = 2, nrow = length(bantu_kincodes), 
#                            dimnames = list((bantu_kincodes), 
#                                            c("Point est.", "Upper C.I.")))

# lh_table = matrix(NA, ncol = length(bantu_kincodes), nrow = 1, 
#                   dimnames = list("Mean"), bantu_kincodes)

lh_table = vector(length = length(bantu_kincodes))
for(i in 1:length(bantu_kincodes)){
  k = bantu_kincodes[i]
  idx = str_detect(files, as.character(k))
  logs = map(files[idx], bt_read.log)
 
  # all_mcmc = mcmc.list(map(logs, function(x) as.mcmc(x$Lh)))
  # d1 = gelman.diag(all_mcmc)
  # gelmanrubin_table[k,] = d1$psrf
  
  idx = str_detect(stones_files, as.character(k))
  stones = map(stones_files[idx], bt_read.stones) 
  
  stones = lapply(stones, function(s) s$marginal_likelihood) %>%
    unlist()
  
  #lh_table[k] = c(stones, harmonic.mean(stones))
  lh_table[i] = stones
}

lh_table2 = data.frame(terminology = bantu_kincodes, MLL = lh_table, row.names = NULL)


print(
    lh_table2 %>% 
    kable(format = format_change, caption = "Table S9: Marginal log-likelihood for each fossilized terminology in Bantu", digits = 3, col.names = c("terminology", "MLL")) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
  )


# print(
#   gelmanrubin_table %>% 
#     kable(format = format_change, 
#           caption = "Table S10: Gelman-Rubin tests of MCMC convergence for each each fossilized model",
#           digits = 3) %>%
#     kable_styling(bootstrap_options = c("striped", "bordered"))
# )
```

#### Bayes factor model comparison

Bayes factor calculations show that there is some evidence for a Iroquoian root over a Hawaiian root (BF = 2.306). The table below shows comparisons to the fossilized Iroquois root to all other fossilized roots. 

```{r fossilized-bantu-bf, results='asis'}
lh = lh_table2[,2]
bf = outer(lh, lh, function(x,y) 2 * (x - y))
dimnames(bf) = list(lh_table2[,1], lh_table2[,1])
bf = data.frame(terminology = colnames(bf) , bf = bf[,"Iroquois"])
colnames(bf) = c("terminology", "Bayes' Factor")

print(
  bf %>% 
    kable(format = format_change, 
          caption = "Table S11: Pariwise Bayes factor between Iroquois and all other possible states.",
          digits = 3, row.names = FALSE) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
```

## PMP in Austronesia

Here we reconstruct the PMP state in Austronesian using the RecNode command in BayesTraits. All other settings remain the same as the Austronesian model. 

```{r, results='asis'}
l = bt_read.log('results/anc-state/pmp/pmp-model.Log.txt')
recnode = l[,44:49] %>% colMeans()

print(
  recnode %>% 
    kable(format = format_change, 
          caption = "Table S12: Ancestral state for PMP",
          digits = 3, row.names = TRUE, 
          col.names = c("Probability")) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
```


## Transition rates

RJ ancestral state analysis also estimates the rate of transition between kinship terminological types. The model constrains the number of parameters estimated, forcing some parameters to be zero, and then estimates and appropriate number of parameters for accurately represent the model. By looking at which parameters are set to zero across the MCMC chain, we can see which transition rates the model believes to be important. We consider transition rates to be important if they are estimated is more than 95% of models.

```{r transition-rates, results='asis'}
# print(
#   kincodes %>% 
#     kable(format = 'html', 
#           caption = "Kin terminologies and their numerical codes.",
#           digits = 3, col.names = NULL) %>%
#     kable_styling(bootstrap_options = c("striped", "bordered"))
# )

new_names = data.frame(
  value = outer(kincodes[,1], kincodes[,1],
                  function(x,y) paste("q", x, y, sep = "")) %>% 
  c(),
  label = outer(kincodes[,2], kincodes[,2],
                  function(x,y) paste(x, y, sep = " -> ")) %>% 
  c()
)

files = list.files('results/transition-rates/', 
                   pattern = ".csv", full.names = TRUE)
i = 13
for(f in files){
  t = read.csv(f)
  colnames(t) = c("transition", 1:(ncol(t)-2), "Z")
  transitions = t[,2:ncol(t)]
  nonzero = rowSums(transitions[,-ncol(transitions)], na.rm = TRUE)
  percent = transitions$Z / rowSums(transitions, na.rm = TRUE)
  
  t = suppressWarnings(left_join(t, new_names, by = c("transition" = "value")))
  
  t2 = data.frame(transition = t$label, 
                  parameterized = nonzero,
                  zero = transitions$Z,
                  percentage =  1 - percent)
  
  t2 = t2[order(t2$percentage, decreasing = TRUE),]
  rownames(t2) = NULL
  
  caption = paste0("Table S", i,": Transition rates between kin terminologies in the ",
                   basename(f) %>% tools::file_path_sans_ext(),
                   " language family.")
  i = i + 1
  
  print(
  t2 %>% 
    kable(format = format_change, 
          caption = caption,
          digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
}
```

## Guillon and Mace comparison

Previous research performed by Guillon and Mace, using similar methods, found support for a Hawaiian root, with some evidence of an Iroquoian root within the Bantu language family. The numerical results for this analysis are not available in the paper. This is the inverse of our result, which found most support for an Iroquoian root, with some support for Hawaiian. This discrepancy is concerning considering the terminological data for both analysis come from d-place. The primary difference between approaches is that here we use a more recently developed phylogeny, and secondarily, Guillon and Mace include missing data, where we exclude it. We re-analysed our data including missing data and found no change in our previous conclusions. Suggesting that the improved phylogeny is driving the change in results. Efforts were made to contact the authors to make more direct comparisons, but with no response. 

```{r results='asis'}
logs = bt_read.log('results/anc-state/guillon-mace-replication/output/18-Dec-2017-12_08.Log.txt')

anc_cols = str_detect(colnames(logs), "Root")

anc_states = colMeans(logs[,anc_cols])

# get the kincode numbers out
kin_numbers = str_extract(names(anc_states), "[0-9]") %>%
  as.numeric()
names(anc_states) = kincodes[kin_numbers,2]

print(
  anc_states %>% 
    kable(format = format_change, 
          caption = 
            "Table S16: Ancestral state of Bantu with missing data included",
          digits = 3, col.names = c("probability")) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"), full_width = FALSE)
)
```


# Co-evolution tests
## MCMC settings
All co-evolutionary analyses was performed in BayesTraits v3.1 using Discrete models [@pagel2006bayesian]. For all models we used an Reversible Jump MCMC approach, and tested an independent and dependent model of evolution. In an independent model, a trait can change, regardless of the state of the other trait. In a dependent model, a trait change is dependent on the state of the second trait. If co-evolution has occurred, the data should fit a dependent model better than it fits an independent model. We test this using Bayes Factors and the same guides as described previously in the paper and SM. Analyses were run between 10,010,000 and 65,000,000 iterations, with burn-ins ranging between 10,000 and 55,000,000, and sampling every 1000 iterations. The results is a posterior of 10,000 iterations, approximately 10 iterations per tree per hypotheses. A stepping stone sampler was used to estimate the marginal likelihood. We used 100 stones sampled every 1,000 iterations. For details of the prior and other settings for each hypotheses, see the table below. 

```{r mcmc.settings}
mcmc = read.csv('analysis/coevo-settings.csv')

mcmc$scale.trees2 = ifelse(mcmc$scale.trees == "ScaleTrees", "Yes", "No")

m = mcmc %>%
  select(job, prior.exp.value, scale.trees2,  
         iterations, sampling, burnin, posterior.size)

kable(m[complete.cases(m),], col.names = 
        c("hypotheses", "exponential mean", 'scaled branch length', "iterations", 
          "sampling", 'burn-in', 'posterior size'), 
      caption = "Table S17: MCMC settings for both dependent and independent analyses", format = format_change) %>% 
  kable_styling()
```

## MCMC review and Bayes Factors

Here we show the results of MCMC chains and respective tests. The first table for each hypotheses is a review of the MCMC chains. Each row shows the marginal log-likelihood and averaged transition rates for the dependent and independent models for a single chain. There are three MCMC chains run for each hypotheses to ensure the model is reaching the same conclusion each time. The penultimate row shows the mean across the three runs. The final row  tests which model was more appropriate for the data. We calculate a Bayes-factor, which compares the log marginal likelihood between the dependent and independent models, as explained in @pagel2006bayesian. A Bayes Factor greater than ten indicates strong support, greater than three positive support and less than three no support.  

A second table shows the results of a Gelman-Rubin diagnostic testing, to test for any significant differences between chains [@gelman1992single]. A value of 1 indicates no difference, and a rule of thumb suggests point-estimates of less than 1.1 indicate negligible differences between chains. 

Some extra analyses are also shown here that are not seen in table 1. These are matrilocal and patrilocal hypotheses and matrilocal.strict and patrilocal.strict. The strict hypothesis exclude anything but societies classified as patrilocal or matrilocal. In the main text we discuss the differences between including virilocality and uxorilocality under each of these hypotheses, there are represented in the 'not strict' hypothesis. 

```{r mcmc.stuff2, results='asis'}
# get three runs of BayesTraits logs
files_1 = list.files('results/co-evolutionary/run-1-newbl/', full.names = TRUE,
                     pattern = "*.Log.txt")
files_2 = list.files('results/co-evolutionary/run-2-newbl/', full.names = TRUE,
                     pattern = "*.Log.txt")
files_3 = list.files('results/co-evolutionary/run-3-newbl/', full.names = TRUE,
                     pattern = "*.Log.txt")
# Get the corresponding runs of BayesTraits Stones
stones_1 = list.files('results/co-evolutionary/run-1-newbl/', full.names = TRUE,
                     pattern = "*.Stones.txt")
stones_2 = list.files('results/co-evolutionary/run-2-newbl/', full.names = TRUE,
                     pattern = "*Stones.txt")
stones_3 = list.files('results/co-evolutionary/run-3-newbl/', full.names = TRUE,
                     pattern = "*.Stones.txt")

for(i in seq_along(m$job)){
  hypotheses = m$job[i] %>% 
    as.character()

  # find the right files
  # This is ithe dependent and independent models for each hypotheses
  idx = str_detect(files_1, paste0(hypotheses, "-"))
  f1 = files_1[idx]
  
  idx = str_detect(files_2, paste0(hypotheses, "-"))
  f2 = files_2[idx]
  
  idx = str_detect(files_3, paste0(hypotheses, "-"))
  f3 = files_3[idx] 
  
  # load the files
  logs = map(list(f1,f2,f3), 
             function(f) map(f, bt_read.log))
  
  if(!all(map(logs, length) == 2)) next # still need to finish up some results 
  # skip for now. 
  
  dep_transitions = map(logs, function(l){
    l = l[[1]]
    transition_cols = str_detect(colnames(l), "(^q)|(^(alpha|beta))")
    #transition = l[,transition_cols] %>% colMeans()
    transition = l[,transition_cols] %>% apply(., 2, median)
    round(transition, 3)
  })
  
  indep_transitions = map(logs, function(l){
    l = l[[2]]
    transition_cols = str_detect(colnames(l), "(^q)|(^(alpha[1,2]|beta[1,2]))")
    transition = l[,transition_cols] %>% apply(., 2, median)
    round(transition, 3)
  })
  
  # find the right stones files
  # this is one for the dependent and one for the independent model
  idx = str_detect(stones_1, hypotheses)
  s1_f = stones_1[idx]
  
  idx = str_detect(stones_2, hypotheses)
  s2_f = stones_2[idx]
  
  idx = str_detect(stones_3, hypotheses)
  s3_f = stones_3[idx] 
  
  s1 = lapply(s1_f, bt_read.stones) %>%
    lapply(., function(s) s$marginal_likelihood)
  s2 = lapply(s2_f, bt_read.stones) %>%
    lapply(., function(s) s$marginal_likelihood)
  s3 = lapply(s3_f, bt_read.stones) %>%
    lapply(., function(s) s$marginal_likelihood)

  stone_logs = list(s1,s2,s3)
  
  dep_table = data.frame(run = 1:3, 
                     dependent.MLL = map_dbl(stone_logs, 1) %>% round(., 3),
                     dependent.transitions = do.call(rbind, dep_transitions)
  )
  
  indep_table = data.frame(independent.MLL = map_dbl(stone_logs, 2) %>% round(., 3),
                           independent.transitions = do.call(rbind, indep_transitions)
  )
  
  table = cbind(dep_table, indep_table)
  table = rbind(table, round(colMeans(table), 3))
  BF = 2 * (s1[[2]] - s1[[1]])
  table[4,1] = "Mean"
  table[5,] = c("BF", round(BF, 3), rep("", 13))

  c.names = c("run", "MLL", 
              colnames(table)[3:10] %>% str_replace_all("dependent.transitions.", ""),
              "MLL", 
              colnames(table)[12:15] %>% str_replace_all("independent.transitions.", "")
  )
              
  caption = hypotheses %>% 
    str_replace("-", " : ") %>%
    str_replace("-", " <-> ") %>%
    paste("Table S", i + 17, ": ", ., sep = "") %>% 
    str_to_title()
  
  print(
    table %>% 
    kable(format = format_change, col.names = c.names, caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered")) %>%
    add_header_above(c(" " = 1, "Dependent" = 9, "Independent" = 5))
  )
  
  ## gelman rubin diagnostics
  if(all(lapply(logs, function(l) map(l, nrow)) %>% unlist())){

    dep_logs = map(logs, 1)
    dmcmc = mcmc.list(map(dep_logs, function(x) as.mcmc(x$Lh)))
    d1 = gelman.diag(dmcmc)
    
    indep_logs = map(logs, 2)
    imcmc = mcmc.list(map(indep_logs, function(x) as.mcmc(x$Lh)))
    d2 = gelman.diag(imcmc)
    
    t2 = do.call(rbind, list(d1$psrf, d2$psrf))
    rownames(t2) = c("Dependent", "Independent")
    
    print(
      t2 %>%
      kable(format = format_change, caption = "Gelman-Rubin MCMC chain diagnostic test", digits = 3) %>%
      kable_styling()  
    )
  }
}
```

### Bantu node 70 state inference

Here we re-construct node 70 within the Bantu tree, to confirm the hypotheses that the presence of both Iroquois terminologies and a preference for cross-cousin marriage existed at this point.

Table 1 in the main text shows that the dependent model is already preferred, so here we only look at the dependent model. The figure below shows the likelihood of each possibility. Top left: Absence of both Iroquois terminology and a preference for cross-cousin marriage. Top right: Absence of cross-cousin marriage and the presence of cross-cousin marriage preference. Bottom right: Both Iroquoian terminologies and cross-cousin marriage preferences are present. Bottom left: presence of an Iroquoian terminology, and absence of a cross-cousin marriage preference. 

The graph clearly shows the presence of both traits being present here is the most likely option, with approximately 0.77 probability. This probability drops to around 0.5 on the ancestral node. 

```{r}
dep = bt_read.log('results/co-evolutionary/bantu-node70/bantu-iroquois-cross.cousinmarriage.preferred-70recon-dep1.Log.txt')

idx_dep = str_detect(colnames(dep), "RecNode")
hist_data = dep[,idx_dep] %>% gather() 
ggplot(gather(hist_data), aes(value)) + 
  geom_histogram(bins = 10) + 
  facet_wrap(~key) +
  ggtitle("Bantu 70: Dependent model") + 
  xlab("Probability") + ylab("Frequency")
```

### Multi-solution models

Some of the hypotheses did not converge satisfactorily despite passing the Gelman-Rubin tests. These often are switching between two possible solutions. Extending burn-in to 2332763595 iterations had no effect of convergence (this is the longest run time allowed by server constraints). Therefore we conclude that these two solutions are equally likely and we qualitatively explore the solutions here. 

#### Austronesian
###### Crow and Matri-anvunculocal residence

There is evidence of two solutions in this model. The most likely model has a likelihood of ~69 (model 1), and a second with a likelihood of ~76 (model 2). The ancestral states are similar, but model 1 shows changes are occurring approximately half as fast as model 2. Under model 1 changes from Crow terminologies to not Crow would occur 200 times every ten years, which seems unlikely. Therefore, model 2 appears to be the most credible model. This means that the likelihood should approximately be -76, which is what the stepping stone sampler arrives at, and not effecting our results. 

```{r echo = FALSE, eval = FALSE}
indep = bt_read.log('results/co-evolutionary/run-1/austronesian-crow-matri.anvunclocalresidence-indep1.Log.txt')
plot.mcmcchain(indep)

stone = bt_read.stones('results/co-evolutionary/run-1/austronesian-crow-matri.anvunclocalresidence-indep1.Stones.txt')

idx = indep$Lh > -74

above = indep[idx,]
below = indep[!idx,]

#as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
as = rbind(colMeans(above[,8:11]), colMeans(below[,8:11])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = format_change, caption = "Table S78: Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = format_change, caption = "Table S79: Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()

```

###### Crow and Matrilineal

The independent model of this hypotheses is multi-modal, as shown in the figure below. Increasing the burn-in and chain length did not increase the preference of one model over the other. We look at the average model for each of these peaks, defining model 1 as the model with a likelihood of approximately -58, and model 2 with a likelihood of approximately -63. The models show similar ancestral states, but a large difference in the rate of change. Beta1 and Beta2 for model 1 are exceptionally high. Beta1 the rate at which societies change from Crow to not Crow is approximately 986 times per 100 years, and Beta2 indicates the rate at which societies loose matrilineal descent is approximately 798 times per 100 years. These rates seem improbable, and lead us to qualitatively prefer model 2. The stepping stone sampler has already shown a value close to this peak is preferable, and this has no change to our conclusion that these two phenomena show signs of co-evolution. 

```{r echo = FALSE, eval = TRUE}
indep = bt_read.log('results/co-evolutionary/run-1/austronesian-crow-matrilineal-indep1.Log.txt')
plot.mcmcchain(indep)

idx = indep$Lh > -60

above = indep[idx,]
below = indep[!idx,]

as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = format_change, caption = "Table S80: Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = format_change, caption = "Table S81: Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()
```


###### Eskimo and Monogamy

This hypotheses is multi-modal and running the chain longer made no decision between the two. In this instance we have two competing solutions, model one suggests it is likely that Eskimo type is the most likely ancestral state, but is uncertain on whether monogamy was also present. Model two suggests that an Eskimo system was not the ancestral state, and neither was monogamy. Ancestral state analyses presented in this paper strongly suggests that Eskimo is very likely to be the ancestral state in Austronesia, so we take model one as the more likely model. The stepping stone sampler already prefers this model, therefore this makes no changes to our results. 

```{r echo = FALSE, eval = TRUE}
indep = bt_read.log('results/co-evolutionary/run-1/austronesian-eskimo-monogamy-indep1.Log.txt')
plot.mcmcchain(indep)

stones = bt_read.stones('results/co-evolutionary/run-1/austronesian-crow-matrilineal-indep1.Stones.txt')

idx = indep$Lh > -70

above = indep[idx,]
below = indep[!idx,]

as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = format_change, caption = "Table S82: Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = format_change, caption = "Table S83: Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()
```

## Multiple comparisons

Since this study has numerous hypothesis tests, it is important we address the statistical problem of multiple comparisons. The multiple comparison problem says that the more hypotheses tested simultaneously, the more likely an erroneous error is to occur. There is strong debate in the literature on whether this is a problem here, but we argue that it is not.

The primary reason for this not being a problem is that all our hypotheses were set out _a priori_. They are not the result of comparing all social variables against all binary kinship terminologies, and make a tiny portion of those that are possible. All hypotheses are established in theory and many had been previously tested. 

## Phylogenetic Inertia

We were concerned that a prevalence of phylogenetic inertia was the primary reason for not finding many significant co-evolutionary relationships. That is, kinship terminologies and social organisation are so tightly tied, that we would not be able to detect a relationship using this approach. To assess how prevalent this was in our results we reviewed each hypothesis on 3 criteria; 1) What was the most likely independent ancestral state, 2) How likely was that ancestral state, and 3) How are the two variables distributed across the respective phylogenies. In an independent model (where each trait changes independent of the other) we would expect that if the ancestral state shows the presence of both traits, there is a possibility that both traits were been inherited over time, either by chance or due to a stable relationship. In both these cases, our phylogenetic approach would fail to pick up a relationship between these traits. The second criteria gives us a level of confidence in the first criteria, we assume a probability of above 0.7 indicates a high likelihood of the true ancestral state. The third criteria allows us to qualitatively review whether we think the methods are failing to detect a relationship, by visualizing the data on mirrored phylogenies. The first two criteria mean that it is plausible that two traits are ancestral, but unrelated, by looking at the distribution of traits on a tree, we can assess whether this is the case or not. Visualization also allows us to attest whether stable pairings occur later within a lineage. These plots can be found in the figures folder in the github repository. Using the three criteria above, we then decide if a hypothesis is likely to be influenced by phylogenetic inertia on a four point scale, ranging from highly likely to highly unlikely. The table below shows these judgments, and ancestral state criteria, for all hypotheses that we did not find support for. These decisions were independently decided on by each author and then conferred on the result. 

```{r}
phylo_interia = read.csv('results/co-evolutionary/phylo-inertia.csv')

phylo_interia %>% 
  kable(format = format_change, caption = "Table S84: Judegments of phylogenetic inertia. The first columns shows our overall judgements. The second column shows the most likely ancestral state in an independent model of evolution, organised as [Kin terminology], [social structure]. The third column shows the probability of this state.", digits = 3, 
        col.names = c("hypothesis", "judgement", "Most likely ancestral state", "Probability of ancestral state")) %>%
      kable_styling()
```


# References