---
title: "Supplementary Material"
author: "Sam Passmore & Fiona Jordan"
date: "01/08/2018"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
options(scipen=999)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warnings = FALSE)

library(knitr)
library(kableExtra)
library(stringr)
library(dplyr)
library(coda)
library(purrr)
library(excdr)
library(psych)
library(ggplot2)
library(gridExtra)
library(tidyr)
library(reshape2)

source('processing/helper.R')

kincodes = read.csv('data/kincodes', header = FALSE)

```

# Data
## Kinship & social structure
All data was extracted from the D-PLACE Ethnographic atlas [github repository](https://github.com/D-PLACE/dplace-data). Counts of the number of societies used for the signal and ancestral state anlyses for each langauges family are in table S1. Question and variable codes are displayed below in table S2. Due to the nature of the analysis, all variables are binary coded. The numbers  in the value columns indicate the criteria for a society to have the terminology or social structure coded as present (i.e. 1). For details on what each code indicates, refer to the Ethnographic Atlas codebook or the [D-PLACE github repository](https://github.com/D-PLACE/dplace-data/blob/master/datasets/EA/codes.csv).


```{r results='asis', message = FALSE}
files = list.files('data/anc-state', pattern = '*.btdata',
                   full.names = TRUE)

d = suppressWarnings(purrr::map(files, read.table))

t = lapply(d, nrow) %>%
  unlist() %>% 
  matrix(., ncol = 1)
dimnames(t) = list(c("Austronesian", "Bantu", "Indo-European", "Uto-Aztecan"), "Count")

kable(t,
      caption = "Table S1: Count of societies in signal test and ancestral state analyses, by language family", 
      format = 'html') %>% 
  kable_styling()
```

```{r, results='asis', message = FALSE}
# summary info
summary = readxl::read_xlsx('../terminology-coevolution2/summary-results.xlsx', sheet = "all")

# data count info
files = list.files('data/co-evo/', pattern = "*.btdata", full.names = TRUE)

d = purrr::map(files, read.table)

t = lapply(d, nrow) %>%
  unlist() %>% 
  data.frame(count = .)
t$id = basename(files) %>% 
  tools::file_path_sans_ext(.)
t$id2 = str_remove(t$id, "(austronesian|bantu|uto)-")
t$lf = str_extract(t$id, "(austronesian|bantu|uto)")

t2 = dcast(t, id2~lf, value.var = "count")
t2 = apply(t2, 2, function(x) ifelse(is.na(x), "", x)) %>% 
  data.frame()

summary = suppressWarnings(left_join(summary, t2, by = "id2"))

s = summary %>% 
  select(terminology, t.question.code, t.value.code, `social structure`,
         ss.question.code, ss.value.code, austronesian.y, bantu.y, uto)

s = s[order(s$terminology),]
s = s[,]

kable(s, col.names = 
        c("terminology", "question code", "value code", "social structure", 
          "question code", 'value code', 'AN counts', 'BT counts', 'UA counts'), 
      caption = "Table S2: Data coding taken from D-PLACE & Co-evolutionary analyses data counts", format = 'html') %>% 
 kable_styling(full_width = TRUE)

```

### Co-evolutionary hypotheses and references

Here we show the the location of the original hypotheses of social structure and kinship terminologies. 

```{r, results='asis', message = FALSE}
quotes = read.csv('figures/hypothesis-table.csv')

kable(quotes, 
      caption = "Table S3: hypotheses with quotes, references and page numbers", format = 'html') %>% 
 kable_styling(full_width = TRUE)
```


## Phylogenies 

We tested hypotheses across three languages families, where data allowed. This was the Austronesian, Bantu, and Uto-Aztecan language phylogenies. All language to phylogeny pairings were taken from decisions made in @kirby2016d.
In Austronesian, we sub-sampled 1000 phylogenies from a posterior sample of 4199 phylogenies developed in @gray2009. Austronesian phylogenies were estimated through linguistic data and supported by genetic evidence, and archaeological records. Detailed methods can be found in @gray2009. Trees were pruned from the original sample of 400 languages, to 80 languages based on data availability. In Bantu, we sampled 1000 from a posterior sample of 2000 phylogenies developed in @grollemund2015bantu. These were developed using linguistic data and calibrated using the archaeological record. Trees were pruned from the original sample of 425 languages, to 69 languages based on data availability. In Uto-Aztecan, we sampled 1000 phylogenies from a posterior of 10000 phylogenies developed by @levinson2011. This was developed using linguistic data. Trees were pruned from the original sample of 34 languages, to 19 based on data availability.

# Signal tests
We performed 4 signal tests to assess the hypotheses that shared ancestry was a constraint on kinship diversity. The phylogenetic ‘D’ test uses simulation to determine whether the clustering of binary variables on a phylogeny follow patterns of Brownian motion (D = 0 indicates perfectly Brownian clusters & D < 0 strong clustering) or random clustering (D = 1 indicates complete randomness). To test whether geography may also predict the distribution of terminologies, we used Mantel tests. Mantel tests use random permutation and Pearson’s correlation statistics to determine the correlation between two matrices. Here we compare log geographic distance, calculated with the haversine formula, to a binary similarity matrix of each terminology present in each language family, each over the default setting of 999 permutations. To determine whether phylogenetic or geographic distances best determined the distribution of terminologies, we used partial mantel tests. Partial Mantel tests control for a confounding variable, while comparing matrices. We perform two tests, one between a terminology and geographic distance, controlling for phylogenetic distance, and one between terminology and phylogenetic distance, controlling for geographic distance. Phylogenetic distance is calculated using cophenetic distance, and the cophenetic function in R {stats} (R Core Team 2018). All results in table S3 show the mean result from 1000 phylogenies. Here we show the results of all these tests for all terminologies present within each language family. However, we only consider results viable if the terminology consists of more than 10% of the overall sample. All p-values are bonferonni corrected. 

The code for all signal tests can be found in file analysis/signal-tests.R. 
This file comes with helper functions `analysis/signal-functions` & `analysis/mantel-functions` for the D-statistic and Mantel tests respectively. 

```{r signal-table, results='asis'}
signal_files = list.files('results/signal-results/', 
                          pattern = "mean.csv", 
                          full.names = TRUE)
idx = !str_detect(signal_files, "ie") # leave IE for now
signal_files = signal_files[idx]

results_lang = map(signal_files, read.csv)
results = do.call(rbind, results_lang)

# make the names nice
results$X = str_remove(results$X, "name")

caption = "Table S3: Signal tests for each terminology within each langauge family. Columns 2 & 3 indicate the presence and absence of a terminology. Columns 4 to 6 are outputs from the D-statistic test. Columns 7 to 21 are output from Mantel tests. P-values and bonferonni corrected values shown"
c.names = c("Terminology", "Absent", "Present", "D", "Prob. Brownian", "Prob. Random", "Z-stat", "p-value","bonf-p", "Z-stat", "p-value", "bonf-p", "Z-stat", "p-value", "bonf-p", "Statistic", "p-value", "bonf-p", "Statistic", "p-value", "bonf-p")

results = results[,c(1:12,16:18,13:15,19:21)]

groups = sapply(results_lang, nrow) %>%
  cumsum()

# idx = results$Present / rowSums(results[,c("Absent", "Present")]) > 0.1
# results = results[idx,]

print(
    results %>% 
    kable(format = 'html', col.names = linebreak(c.names), 
          caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = 
                    c("striped", "bordered")) %>%
      group_rows("Austronesian", 1, groups[1]) %>%
      group_rows("Bantu", groups[1]+1, groups[2]) %>%
      group_rows("Uto-Aztecan", groups[2]+1, groups[3]) %>% 
      add_header_above(c(" " = 3, "D-statistic" = 3, 
                         "Geography" = 3, "Log-Geography" = 3,
                         "Phylogeny" = 3, "Log-Geo + Phy" = 3,
                         "Phy + Log Geo" = 3)) %>%
      add_header_above(c(" " = 6, "Mantel" = 9, 
                         "Partial Mantel" = 6)))

```

# Ancestral state
## MCMC review
Ancestral state reconstruction allows us to estimate the probability of a particular terminology at the root of each language phylogeny, as well as estimating the patterns of change between each state. We perform Bayesian reversible-jump MCMC ancestral reconstructions kinship terminologies using BayesTraits V 3.0 Multistate (Pagel and Meade 2017). The advantage of the MCMC approach over a maximum likelihood approach is that it allows the result to be integrated over the sample of trees. Multistate uses a posterior of phylogenies to estimate the probability of each terminology present in the taxa at the phylogeny root, and an estimation of the rate (Q) matrix. The reversible-jump approach searches the model space for an optimal solution by dynamically setting some rate parameters (i.e. transitions from one state to another) to zero. This results in searching the model space where we are confident transition rates are non-zero. The Q matrix shows the likelihood of changing from any state to any other. MCMC chains were run for 10^9^ iterations, sampling every 50 000 iterations with a burn-in of 10 000 iterations, to give a posterior sample of 19 999. Each analysis ran three times to test consistent MCMC convergence using the Gelman-Rubin diagnostic (Gelman and Rubin 1992). Due to uncertainty in the reconstruction of the Bantu ancestral state, each possible taxa was fossilized as the root to estimate likelihoods. We calculate pairwise Bayes factors (BF) to assess the evidence for each response. BF < 2 indicates weak evidence, > 2 positive evidence, 5-10 strong evidence, and >10 very strong evidence. This involves the same process as above, but forcing the model to assume an ancestral state and using model comparison to determine the most likely ancestral state. 

```{r ancstate-mcmc, results='asis'}
folders = paste0('results/anc-state/', c('austronesian', 'bantu', 'utoaztecan'))
gelmanrubin_table = matrix(NA, ncol = 2, nrow = 3, 
                           dimnames = list(basename(folders), 
                                           c("Point est.", "Upper C.I.")))
for(f in folders){
  files = list.files(path = f, pattern = "*.Log.txt", full.names = TRUE)
  logs = map(files, read.bayestraits)
  
  roots = map(logs, function(l){
    root_cols = str_detect(colnames(l), "(^Lh)|(^Root)")
    root = l[,root_cols] %>% colMeans()
    round(root, 3)
  }) %>% 
    do.call(rbind, .)
  
  idx = str_detect(colnames(roots), "Root")
  old_names = colnames(roots)[idx] %>% 
    str_extract("[0-9]") %>% 
    as.numeric()
  new_names = kincodes[kincodes$V1 %in% old_names,2]
  colnames(roots)[idx] = as.character(new_names)
  
  roots = rbind(roots, colMeans(roots))
  rownames(roots) = c(1:3, "Mean")
  # gelman-rubin statistic
  all_mcmc = mcmc.list(map(logs, function(x) as.mcmc(x$Lh)))
  d1 = gelman.diag(all_mcmc)
  rownames(d1$psrf) = basename(f)
  
  gelmanrubin_table[basename(f),] = d1$psrf
  
  caption = paste0("Three MCMC chains for the ", basename(f), " language family")
  
  ## print table
  print(
    roots %>% 
    kable(format = 'html', caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
  )
}

print(
  gelmanrubin_table %>% 
    kable(format = 'html', 
          caption = "Gelman-Rubin tests of MCMC convergence for each langauge family",
          digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)

```

### Fossilized Bantu
#### MCMC Review

We fossilize the ancestral state for each possible terminology within Bantu in an attempt to determine the most plausible ancestral state. Below are the MCMC diagnostics for these models and the result with comparisons to an Iroquoian fossilized ancestral state. 

```{r fossilized-bantu-mcmc, results='asis'}
files = list.files('results/anc-state/fossilized-bantu/', pattern = "Log.txt", 
                   full.names = TRUE)

stones_files = list.files('results/anc-state/fossilized-bantu/', pattern = "Stones.txt", 
                   full.names = TRUE)

bantu_kincodes = stones_files %>% 
  basename() %>% 
  str_split("_") %>%
  sapply(extract2, 1) %>% 
  unique()

gelmanrubin_table = matrix(NA, ncol = 2, nrow = length(bantu_kincodes), 
                           dimnames = list((bantu_kincodes), 
                                           c("Point est.", "Upper C.I.")))

lh_table = matrix(NA, ncol = length(bantu_kincodes), nrow = 4, 
                  dimnames = list(c(1:3, "Mean"), bantu_kincodes))

for(k in bantu_kincodes){
  idx = str_detect(files, as.character(k))
  logs = map(files[idx], read.bayestraits)
 
  all_mcmc = mcmc.list(map(logs, function(x) as.mcmc(x$Lh)))
  d1 = gelman.diag(all_mcmc)
  gelmanrubin_table[k,] = d1$psrf
  
  idx = str_detect(stones_files, as.character(k))
  stones = map(stones_files[idx], read.stones) %>% 
    unlist()
  
  lh_table[,k] = c(stones, harmonic.mean(stones))
}

  print(
    lh_table %>% 
    kable(format = 'html', caption = "Marginal log-likelihood for three runs of each fossilized terminology in Bantu", digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
  )


print(
  gelmanrubin_table %>% 
    kable(format = 'html', 
          caption = "Gelman-Rubin tests of MCMC convergence for each each fossilized model",
          digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)

```

#### Bayes factor model comparison

Bayes factor calculations show that there is some evidence for a Iroquoian root over a Hawaiian root (BF = 2.957). The table below shows comparisons to the fossilized Iroquois root to all other fossilized roots. 

```{r fossilized-bantu-bf, results='asis'}
lh = lh_table[4,]
bf = outer(lh, lh, function(x,y) 2 * (x - y))
bf = data.frame(terminology = colnames(bf) , bf = bf["Iroquois",])
colnames(bf) = c("terminology", "Bayes' Factor")

print(
  bf %>% 
    kable(format = 'html', 
          caption = "Pariwise Bayes factor between Iroquois and all other possible states.",
          digits = 3, row.names = FALSE) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
```

## Transition rates

RJ ancestral state analysis also estimates the rate of transition between kinship terminological types. The model constrains the number of parameters estimated, forcing some parameters to be zero, and then estimates and appropriate number of parameters for accurately represent the model. By looking at which parameters are set to zero across the MCMC chain, we can see which transition rates the model believes to be important. We consider transition rates to be important if they are set to zero in less than 1% of models. That is, the model considered these transitions important in 99% of the iterations. Transition rates are coded by numerical codes, which are:

```{r transition-rates, results='asis'}
print(
  kincodes %>% 
    kable(format = 'html', 
          caption = "Kin terminologies and their numerical codes.",
          digits = 3, col.names = NULL) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)

files = list.files('results/transition-rates/', pattern = ".csv", full.names = TRUE)
for(f in files){
  t = read.csv(f)
  colnames(t) = c("transition", 1:(ncol(t)-2), "Z")
  transitions = t[,2:ncol(t)]
  nonzero = rowSums(transitions[,-ncol(transitions)], na.rm = TRUE)
  percent = transitions$Z / rowSums(transitions, na.rm = TRUE)
  
  t2 = data.frame(transition = t$transition, 
                  parameterized = nonzero,
                  zero = transitions$Z,
                  percentage = percent)
  
  t2 = t2[order(t2$percentage, decreasing = FALSE),]
  rownames(t2) = NULL
  
  caption = paste0("Transition rates between kin terminologies in the ",
                   basename(f) %>% tools::file_path_sans_ext(),
                   " language family.")
  
  print(
  t2 %>% 
    kable(format = 'html', 
          caption = caption,
          digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
}
```

## Guillon & Mace comparison

Previous research performed by Guillon and Mace, using similar methods, found support for a Hawaiian root, with some evidence of an Iroquoian root within the Bantu langauge family. This is the inverse of our result, which found most support for an Iroquoian root, with some support for Hawaiian. This discrepancy is concerning considering the terminological data for both analysis come from the same source. The analysis here uses a more recently developed phylogeny, but more importantly, Guillon and Mace include missing data, where we exclude it. We re-analysed our data including missing data and found no change in our previous conclusions. Suggesting that the improved phylogeny is driving the change in results. Efforts were made to contact the authors to make more direct comparisons, but with no response. 

```{r results='asis'}
logs = read.bayestraits('results/anc-state/guillon-mace-replication/output/18-Dec-2017-12_08.Log.txt')

anc_cols = str_detect(colnames(logs), "Root")

anc_states = colMeans(logs[,anc_cols])

# get the kincode numbers out
kin_numbers = str_extract(names(anc_states), "[0-9]") %>%
  as.numeric()
names(anc_states) = kincodes[kin_numbers,2]

print(
  anc_states %>% 
    kable(format = 'html', 
          caption = 
            "Ancestral state of Bantu with missing data included",
          digits = 3, col.names = c("probability")) %>%
    kable_styling(bootstrap_options = c("striped", "bordered"))
)
```


# Co-evolution tests
## MCMC settings
All co-evolutionary analyses was performed in BayesTraits v3.1 using Discrete models [@pagel2006bayesian]. For all models we used an Reversible Jump MCMC approach, and tested an independent and dependent model of evolution. In an independent model, a trait can change, regardless of the state of the other trait. In a dependent model, a trait change is dependent on the state of the second trait. If co-evolution has occurred, the data should fit a dependent model better than it fits an independent model. Analyses were run between 10010000 and 65000000 iterations, with burn-ins ranging between 10000 and 55000000, and sampling every 1000 iterations. This results is a posteriot of 10000 iterations, approximately 10 iterations per tree. A stepping stone sampler was used to estimate the marginal likelihood. We used 100 stones sampled every 1000 iterations. For details of the prior and other settings for each hypotheses, see table S2. 

```{r mcmc.settings}
mcmc = read.csv('analysis/coevo-settings.csv')

mcmc$scale.trees2 = ifelse(mcmc$scale.trees == "ScaleTrees", "Yes", "No")

m = mcmc %>%
  select(job, prior.exp.value, scale.trees2,  
         iterations, sampling, burnin, posterior.size)

kable(m[complete.cases(m),], col.names = 
        c("hypotheses", "exponential mean", 'scaled branch length', "iterations", 
          "sampling", 'burn-in', 'posterior size'), 
      caption = "Table S2: MCMC settings for both dependent and independent analyses", format = 'html') %>% 
  kable_styling()
```

## MCMC review & Bayes Factors

Here we show the results of MCMC chains and respective tests. The first table for each hypotheses is a review of the MCMC chains. Each row shows the marginal log-likelihood and averaged transition rates for the dependent and independent models for a single chain. There are three MCMC chains run for each hypotheses to ensure the model is reaching the same conclusion each time. The penultimate row shows the mean across the three runs. The final row  tests which model was more appropriate for the data. We calculate a Bayes-factor, which compares the log marginal likelihood between the dependent and independent models, as explained in @pagel2006bayesian. Following common practice we interpret Bayes factors of less than two as no support for co-evolution. Between two and five as positive support, between five and ten as strong support and above ten as very strong support.  

A second table shows the results of a Gelman-Rubin diagnostic testing, to test for any significant differences between chains [@gelman1992single]. A value of 1 indicates no difference, and a rule of thumb suggests point-estimates of less than 1.1 indicate negligible differences between chains. 

```{r mcmc.stuff2, results='asis'}
# get three runs of BayesTraits logs
files_1 = list.files('results/co-evolutionary/run-1/', full.names = TRUE,
                     pattern = "*.Log.txt")
files_2 = list.files('results/co-evolutionary/run-2/', full.names = TRUE,
                     pattern = "*.Log.txt")
files_3 = list.files('results/co-evolutionary/run-3/', full.names = TRUE,
                     pattern = "*.Log.txt")
# Get the corresponding runs of BayesTraits Stones
stones_1 = list.files('results/co-evolutionary/run-1/', full.names = TRUE,
                     pattern = "*.Stones.txt")
stones_2 = list.files('results/co-evolutionary/run-2/', full.names = TRUE,
                     pattern = "*Stones.txt")
stones_3 = list.files('results/co-evolutionary/run-3/', full.names = TRUE,
                     pattern = "*.Stones.txt")

for(i in seq_along(m$job)){
  hypotheses = m$job[i] %>% 
    as.character()

  # find the right files
  # This is ithe dependent and independent models for each hypotheses
  idx = str_detect(files_1, hypotheses)
  f1 = files_1[idx]
  
  idx = str_detect(files_2, hypotheses)
  f2 = files_2[idx]
  
  idx = str_detect(files_3, hypotheses)
  f3 = files_3[idx] 
  
  # load the files
  logs = map(list(f1,f2,f3), 
             function(f) map(f, read.bayestraits))
  
  if(!all(map(logs, length) == 2)) next # still need to finish up some results 
  # skip for now. 
  
  dep_transitions = map(logs, function(l){
    l = l[[1]]
    transition_cols = str_detect(colnames(l), "(^q)|(^(alpha|beta))")
    #transition = l[,transition_cols] %>% colMeans()
    transition = l[,transition_cols] %>% apply(., 2, median)
    round(transition, 3)
  })
  
  indep_transitions = map(logs, function(l){
    l = l[[2]]
    transition_cols = str_detect(colnames(l), "(^q)|(^(alpha[1,2]|beta[1,2]))")
    transition = l[,transition_cols] %>% apply(., 2, median)
    round(transition, 3)
  })
  
  # find the right stones files
  # this is one for the dependent and one for the independent model
  idx = str_detect(stones_1, hypotheses)
  s1 = stones_1[idx]
  
  idx = str_detect(stones_2, hypotheses)
  s2 = stones_2[idx]
  
  idx = str_detect(stones_3, hypotheses)
  s3 = stones_3[idx] 
  
  s1 = lapply(s1, read.stones)
  s2 = lapply(s2, read.stones)
  s3 = lapply(s3, read.stones)

  stone_logs = list(s1,s2,s3)
  
  dep_table = data.frame(run = 1:3, 
                     dependent.MLL = map_dbl(stone_logs, 1) %>% round(., 3),
                     dependent.transitions = do.call(rbind, dep_transitions)
  )
  
  indep_table = data.frame(independent.MLL = map_dbl(stone_logs, 2) %>% round(., 3),
                           independent.transitions = do.call(rbind, indep_transitions)
  )
  
  table = cbind(dep_table, indep_table)
  table = rbind(table, round(colMeans(table), 3))
  BF = 2 * (s1[[1]] - s1[[2]])
  table[4,1] = "Mean"
  table[5,] = c("BF", round(BF, 3), rep("", 13))

  c.names = c("run", "MLL", 
              colnames(table)[3:10] %>% str_replace_all("dependent.transitions.", ""),
              "MLL", 
              colnames(table)[12:15] %>% str_replace_all("independent.transitions.", "")
  )
              
  caption = hypotheses %>% 
    str_replace("-", " : ") %>%
    str_replace("-", " <-> ") %>%
    str_to_title()
  
  print(
    table %>% 
    kable(format = 'html', col.names = c.names, caption = caption, digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "bordered")) %>%
    add_header_above(c(" " = 1, "Dependent" = 9, "Independent" = 5))
  )
  
  ## gelman rubin diagnostics
  if(all(lapply(logs, function(l) map(l, nrow)) %>% unlist())){

    dep_logs = map(logs, 1)
    dmcmc = mcmc.list(map(dep_logs, function(x) as.mcmc(x$Lh)))
    d1 = gelman.diag(dmcmc)
    
    indep_logs = map(logs, 2)
    imcmc = mcmc.list(map(indep_logs, function(x) as.mcmc(x$Lh)))
    d2 = gelman.diag(imcmc)
    
    t2 = do.call(rbind, list(d1$psrf, d2$psrf))
    rownames(t2) = c("Dependent", "Independent")
    
    print(
      t2 %>%
      kable(format = 'html', caption = "Gelman-Rubin MCMC chain diagnostic test", digits = 3) %>%
      kable_styling()  
    )
  }
}
```

### Bantu node 70 Reconstruction

Here we re-construct node 70 within the Bantu tree, to confirm the hypotheses that the presence of both Iroquois terminologies and a preference for cross-cousin marriage existed at this point.

Table 1 in the main text shows that the dependent model is already preferred, so here we only look at the dependent model. The figure below shows the likelihood of each possibility. Top left: Absence of both Iroquois terminology & a preference for cross-cousin marriage. Top right: Absence of cross-cousin marriage and the presence of cross-cousin marriage preference. Bottom right: Both Iroquoian terminologies and cross-cousin marriage preferences are present. Bottom left: presence of an Iroquoian terminology, and absence of a cross-cousin marriage preference. 

The graph clearly shows the presence of both traits being present here is the most likely option, with approximately 0.77 probability. This probability drops to around 0.5 on the ancestral node. 

```{r}
dep = read.bayestraits('results/co-evolutionary/bantu-node70/bantu-iroquois-cross.cousinmarriage.preferred-70recon-dep1.Log.txt')

idx_dep = str_detect(colnames(dep), "RecNode")
hist_data = dep[,idx_dep] %>% gather() 
ggplot(gather(hist_data), aes(value)) + 
  geom_histogram(bins = 10) + 
  facet_wrap(~key) +
  ggtitle("Bantu 70: Dependent model") + 
  xlab("Probability") + ylab("Frequency")
```

### Multi-solution models

Some of the hypotheses did not converge satisfactorily despite passing the Gelman-Rubin tests. These often are switching between two possible solutions. Extending burn-in to 2332763595 iterations had no effect of convergence. Therefore we conclude that these two solutions are equally likely and we explore the impact of these here. 

#### Austronesian
###### Crow & Matri-anvunculocal residence

There is evidence of two solutions in this model. The most likely model has a likelihood of ~69 (model 1), and a second with a likelihood of ~76 (model 2). The ancestral states are similar, but model 1 shows changes are occurring approximately half as fast as model 2. Under model 1 changes from Crow terminologies to not Crow would occur 200 times every ten years, which seems unlikely. Therefore, we qualitatively choose model 2 as the most likely model. This means that the likelihood should approximately be -76, which is what the stepping stone sampler chose, therefore not effecting our results. 

```{r echo = FALSE}
indep = read.bayestraits('results/co-evolutionary/run-1/austronesian-crow-matri.anvunclocalresidence-indep1.Log.txt')
plot.mcmcchain(indep)

stone = read.stones('results/co-evolutionary/run-1/austronesian-crow-matri.anvunclocalresidence-indep1.Stones.txt')

idx = indep$Lh > -75

above = indep[idx,]
below = indep[!idx,]

as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = 'html', caption = "Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = 'html', caption = "Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()

```

###### Crow & Matrilineal

The independent model of this hypotheses is multimodel, as shown in the figure below. Increasing the burn-in and chain length did not increase the preference of one model over the other. We look at the average model for each of these peaks, defining model 1 as the model with a likelihood of approximately -58, and model 2 with a likelihood of approximately -63. The models show similar ancestral states, but a large difference in the rate of change. Beta1 and Beta2 for model 1 are exceptionally high. Beta1 the rate at which societies change from Crow to not Crow is approximately 986 times per 100 years, and Beta2 indicates the rate at which societies loose matrilineal descent is approximately 798 times per 100 years. These rates seem improbable, and lead us to qualitatively prefer model 2. The stepping stone sampler has already shown a value close to this peak is preferable, and this has no change to our conclusion that these two phenomena show signs of co-evolution. 

```{r echo = FALSE}
indep = read.bayestraits('results/co-evolutionary/run-1/austronesian-crow-matrilineal-indep1.Log.txt')
plot.mcmcchain(indep)

idx = indep$Lh > -61

above = indep[idx,]
below = indep[!idx,]

as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = 'html', caption = "Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = 'html', caption = "Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()
```



###### Eskimo & Monogamy

This hypotheses is multi-modal and running the chain longer made no decision between the two. In this instance we have two competeing solutions, model one suggests it is likely that Eskimo type is the most likely ancestral state, but is split between whether monogamy was also present. And model two suggests that an Eskimo system was not the ancestral state, and neither was monogamy. Other analysis in this paper suggests that Eskimo is very likely to be the ancestral state in Austronesia, so we take model one as the most likely model. The stepping stone sampler already prefers this model, therefore this makes no changes to our results. 

```{r echo = FALSE}
indep = read.bayestraits('results/co-evolutionary/run-1/austronesian-eskimo-monogamy-indep1.Log.txt')
plot.mcmcchain(indep)

stones = read.stones('results/co-evolutionary/run-1/austronesian-crow-matrilineal-indep1.Stones.txt')

idx = indep$Lh > -70

above = indep[idx,]
below = indep[!idx,]

as = rbind(colMeans(above[,11:14]), colMeans(below[,11:14])) 
rownames(as) = c("model 1", "model 2")

as %>% 
  kable(format = 'html', caption = "Ancestral states for model 1 and model 2", digits = 3) %>%
      kable_styling()

rates = rbind(colMeans(above[,7:10]), colMeans(below[,7:10])) 
rownames(rates) = c("model 1", "model 2")

rates %>% 
  kable(format = 'html', caption = "Independent rates for model 1 and model 2", digits = 3) %>%
      kable_styling()
```

## Multiple comparisons

Since this study has numerous hypothesis tests, it is important we address the statistical problem of multiple comparisons. The multiple comparison problem says that the more hypotheses tested simultaneously, the more likely an erroneous error is to occur. There is strong debate in the literature on whether this is a problem here, but we argue that it is not.

The primary reason for this not being a problem is that all our hypotheses were set out _a priori_. They are not the result of comparing all social variables against all binary kinship terminologies, and make a tiny portion of those that are possible. All hypotheses are established in theory and many had been previously tested. 

